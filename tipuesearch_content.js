var tipuesearch = {"pages":[{"title":"Python元类编程(一)","text":"注解 这篇文章翻译自 https://python-3-patterns-idioms-test.readthedocs.io/en/latest/Metaprogramming.html 非逐字翻译，结合了我的个人理解。 python 中所有对象都是由其它一种特殊对象\"class\"创建，也就是叫做类的这个对象，我们可以像修改普通对象一样去修改这个\"类\"对象。 >>> class Foo : pass ... >>> Foo . field = 42 >>> x = Foo () >>> x . field 42 >>> Foo . field2 = 99 >>> x . field2 99 >>> Foo . method = lambda self : \"Hi!\" >>> x . method () 'Hi!' 修改\"类\"对象（上例 Foo ）就像平常操作修改其它对象一样，例如，你可以往对象上添加方法，属性，或者删除对象上的方法，属性。不同于修改普通 对象在于任何对于\"类\"这个对象的修改，会影响到这个类对象之后实例化的所有对象，包括已经被实例化的对象。 那么是什么创建了这个特殊的\"类\"对象，这里引出另一个特殊的对象我们称作 metaclass python里默认的元类被称为 type 大多数情况下，开发者并不需要关心它，但在特殊情况通过修改\"类\"对象的生成方式，可以得到更好的问题解决办法， 特别是执行额外的操作或者注入代码，在这种情况通过使用元类编程达到修改\"类\"对象的生成方式。 这里值得再次强调一遍，在大多数情况下不需要使用元类，不必刻意去使用元类。下面的例子中会给出一个问题使用元类以及不使用元类的两种解决办法，你将 会看到解决问题的更简单形式。 在先前python的实现中，一些只能由元类实现的功能，现在也可以通过使用类装饰器以更简单的方式来完成，但是理解元类本身依然非常有用，一些问题现在 依然只能由元类编程来实现。 元类编程基础 所以在python中元类 metaclass 实际创建了\"类\" class 类然后创建了类的实例，通常我们构造类时，默认的元类 type 会被自动调用并 创建出我们指定的\"类\"对象，这个过程开发者是无感知的。 这里可以用显式的代码来展现元类创建\"类\"对象的过程。 type 接收一个参数调用时，会返回现有类的类型信息，例如 type('He') -> str 但当 type 以三个参数被调用将创建一个\"类\"对象，调用 type 的三个参数分别是类型名称，被创建类的基类型列表，以及指定被创建类的命名空间（一 个包含所有变量以及方法的字典），例如下面两段代码都是等价的。 class C : pass 等价于 C = type ( 'C' , (), {}) \"类\"对象通常也被引作为类型，所以上面的示例中调用 type 非常合理，即通过参数调用type创建了一个新的类型 \"C\" 。 我们可以给这个\"类\"对象加上基类，以及方法和属性，例如 def howdy ( self , you ): print ( \"Howdy, \" + you ) MyList = type ( 'MyList' , ( list ,), dict ( x = 42 , howdy = howdy )) ml = MyList () ml . append ( \"Camembert\" ) print ( ml ) print ( ml . x ) ml . howdy ( \"John\" ) print ( ml . __class__ . __class__ ) \"\"\" Output: ['Camembert'] 42 Howdy, John <class 'type'> \"\"\" 注意上面打印类型的类型会返回该类型的元类。 这种使用 type 以编程的形式生成\"类\"的能力可以带来一些有趣的可能性。看下面的例子，所有的子类都使用重复的代码写出，但现在我们可以借助 type 的能力来自动生成子类。 import operator class Event ( object ): events = [] # static def __init__ ( self , action , time ): self . action = action self . time = time Event . events . append ( self ) def __lt__ ( self , other ): \"So sort() will compare only on time.\" return operator . lt ( self . time , other . time ) def __eq__ ( self , other ): return operator . eq ( self . time , other . time ) def run ( self ): print ( \" %.2f : %s \" % ( self . time , self . action )) @staticmethod def run_events (): Event . events . sort (); for e in Event . events : e . run () def create_mc ( description ): \"Create subclass using the 'type' metaclass\" class_name = \"\" . join ( x . capitalize () for x in description . split ()) def __init__ ( self , time ): Event . __init__ ( self , description + \" [mc]\" , time ) globals ()[ class_name ] = type ( class_name , ( Event ,), dict ( __init__ = __init__ )) def create_exec ( description ): \"Create subclass by exec-ing a string\" class_name = \"\" . join ( x . capitalize () for x in description . split ()) klass = \"\"\" class %s (Event): def __init__(self, time): Event.__init__(self, \" %s [exec]\", time) \"\"\" % ( class_name , description ) exec ( klass , globals ()) if __name__ == \"__main__\" : descriptions = [ \"Light on\" , \"Light off\" , \"Water on\" , \"Water off\" , \"Thermostat night\" , \"Thermostat day\" , \"Ring bell\" ] initializations = \"ThermostatNight(5.00); LightOff(2.00); \\ WaterOn(3.30); WaterOff(4.45); LightOn(1.00); \\ RingBell(7.00); ThermostatDay(6.00)\" [ create_mc ( dsc ) for dsc in descriptions ] exec initializations in globals () [ create_exec ( dsc ) for dsc in descriptions ] exec initializations in globals () Event . run_events () \"\"\" Output: 1.00: Light on [mc] 1.00: Light on [exec] 2.00: Light off [mc] 2.00: Light off [exec] 3.30: Water on [mc] 3.30: Water on [exec] 4.45: Water off [mc] 4.45: Water off [exec] 5.00: Thermostat night [mc] 5.00: Thermostat night [exec] 6.00: Thermostat day [mc] 6.00: Thermostat day [exec] 7.00: Ring bell [mc] 7.00: Ring bell [exec] \"\"\" 所有事件的基类 Event 是相同的, 这里使用 create_mc 函数来自动在全局命名空间中创建出了各种事件类型,该函数接收description参数并 以此创建出类型名字然后将类型注册在全局命名空间中，函数内部定义的 __init__ 方法，通过调用 type 注册在类型的命名空间上，从而生了 Event 的新的子类。注意，这里生成的类对象必须放入全局命名空间，才可以在外部正常访问到。 这种方法工作良好，但是考虑下 create_exec 函数，它通过声明的类型字符串调用 exec 实现了相同的事情，这对于大多数不理解元类的人阅读 代码来说更容易一点。 元类钩子 到目前为止，我们只直接使用了元类 type 。 元类操作涉及将我们自己的代码注入到\"类\"对象的创建过程中，通过以下步骤实现： 继承元类 type 在子类钩子方法中插入我们自己的代码 将我们自己的元类插入\"类\"对象的创建过程中通过 metaclass 钩子 在 python2.x 中 metaclass 钩子是类上的一个静态字段 __metaclass__ 通常情况下这个变量是不赋值的，所以python只使用 type 来创建类，但是如果你在类上定义这个字段指向一个 callable 可调用对象，python将会在初使创建类对象后，调用 __metaclass__() 并传 入类对象，类名，基类列表，以及类型的命名空间字典。 python2.x中也允许给全局 __metaclass__ 赋值, 如果没有在类中声明 __metaclass__ 则全局的会被使用。（在python3.x是否有等价的钩子？） 因此，基本的元类编程就像下面这样： class SimpleMeta1(type): def __init__(cls, name, bases, nmspc): super(SimpleMeta1, cls).__init__(name, bases, nmspc) cls.uses_metaclass = lambda self : \"Yes!\" class Simple1(object): __metaclass__ = SimpleMeta1 def foo(self): pass @staticmethod def bar(): pass simple = Simple1() print([m for m in dir(simple) if not m.startswith('__')]) # A new method has been injected by the metaclass: print(simple.uses_metaclass()) \"\"\" Output: ['bar', 'foo', 'uses_metaclass'] Yes! \"\"\" 在python3.x版本中则是 class SimpleMeta1(type): def __init__(cls, name, bases, nmspc): super(SimpleMeta1, cls).__init__(name, bases, nmspc) cls.uses_metaclass = lambda self : \"Yes!\" class Simple1(metaclass=SimpleMeta1): def foo(self): pass @staticmethod def bar(): pass simple = Simple1() print([m for m in dir(simple) if not m.startswith('__')]) # A new method has been injected by the metaclass: print(simple.uses_metaclass()) \"\"\" Output: ['bar', 'foo', 'uses_metaclass'] Yes! \"\"\" 按照惯例定义元类时除了 __new__ 方法外 cls 作为元类上所有方法的第一个参数而不是通常的 self ，原因是 __new__ 方法的第一 个参数是 mcl 原因在下面解释， cls 是要被修改的\"类\"对象。 注意在派生类构造方法中首先调用基类的的构造方法（通过 super() ）的做法在元类中也是一样。 实际上 __metaclass__ 需要的是一个 callable 可调用的对象，所以在 python2.x 中可以将 __metaclass__ 定义为内联的形式。 class Simple2 ( object ): class __metaclass__ ( type ): def __init__ ( cls , name , bases , nmspc ): # This won't work: # super(__metaclass__, cls).__init__(name, bases, nmspc) # Less-flexible specific call: type . __init__ ( cls , name , bases , nmspc ) cls . uses_metaclass = lambda self : \"Yes!\" class Simple3 ( Simple2 ): pass simple = Simple3 () print simple . uses_metaclass () \"\"\" Output: Yes! \"\"\" 注意上例中编译器不会接受 super 的调用, 因为 __metaclass__ 尚未定义，这迫使使用 type.__init__(cls, name, bases, nmspc) 进行特殊的调用。 因为 __metaclass__ 仅仅需要的是一个可调用的对象，所以甚至可以将 __metaclass__ 定义为一个函数。 class Simple4 ( object ): def __metaclass__ ( name , bases , nmspc ): cls = type ( name , bases , nmspc ) cls . uses_metaclass = lambda self : \"Yes!\" return cls simple = Simple4 () print simple . uses_metaclass () \"\"\" Output: Yes! \"\"\" 就像你所看到的，在python3.x中不允许最后这两个例子一样的语法。但即使这样，上面的例子已经清楚的展示了元类发生了什么：创建类对象，然后修改，然 后返回。 在python3.x中的元类钩子 python3.x 改变了元类的钩子，虽然没有禁止类中声明 __metaclass__ 字段，但是它会忽略这个字段。取而代之的是，在基类列表中使用一个关键字 参数。 class Simple1 ( object , metaclass = SimpleMeta1 ): ... 这就意味着在python3.x中没有任何直接将 __metaclass__ 定义为类或者函数的可能，所有的元类都必须定义为单独的类，这大概是一件好事，它使得 元类编程更加一致，从而更容易的阅读和理解。 例子：子类自我注册 使用继承作为一种组织方式有时候很方便，每一个子类都成为你所处理的组的一个元素，例如 Language 可以是所有的语言的一个基类，每种特定的语言 子类都描述了特定的语言特征。 要解决这个问题，考虑这样一个系统，它自动保存所有\"叶子\"子类的一个列表（类没有继承者），通过这种方式我们可以很容易的枚举所有的子类型。 class RegisterLeafClasses ( type ): def __init__ ( cls , name , bases , nmspc ): super ( RegisterLeafClasses , cls ) . __init__ ( name , bases , nmspc ) if not hasattr ( cls , 'registry' ): cls . registry = set () cls . registry . add ( cls ) cls . registry -= set ( bases ) # Remove base classes # Metamethods, called on class objects: def __iter__ ( cls ): return iter ( cls . registry ) def __str__ ( cls ): if cls in cls . registry : return cls . __name__ return cls . __name__ + \": \" + \", \" . join ([ sc . __name__ for sc in cls ]) class Color ( metaclass = RegisterLeafClasses ): pass class Blue ( Color ): pass class Red ( Color ): pass class Green ( Color ): pass class Yellow ( Color ): pass print ( Color ) class PhthaloBlue ( Blue ): pass class CeruleanBlue ( Blue ): pass print ( Color ) for c in Color : # Iterate over subclasses print ( c ) class Shape ( metaclass = RegisterLeafClasses ): class Round ( Shape ): pass class Square ( Shape ): pass class Triangular ( Shape ): pass class Boxy ( Shape ): pass print ( Shape ) class Circle ( Round ): pass class Ellipse ( Round ): pass print ( Shape ) \"\"\" Output: Color: Red, Blue, Green, Yellow Color: Red, CeruleanBlue, Green, PhthaloBlue, Yellow Red CeruleanBlue Green PhthaloBlue Yellow Shape: Square, Round, Boxy, Triangular Shape: Square, Ellipse, Circle, Boxy, Triangular \"\"\" 两个单独的测试代码，表明两个元类的注册中心是相互独立的。每个测试例子，都展示了添加另一个叶类时发生的情况，前一层叶类成为基类，因此从注册表中 移除。 上面也引入类元类方法，定义在元类中的方法，以便它们成为\"类\"对象的方法，也就是说在\"类\"这个对象而不是类的实例上去调用这些方法，这些方法的第一个 参数是\"类\"对象 cls 而不是 self 。 例子：让类变成 \"Final\" 一些情况下需要防止类被继承是很方便的： # Emulating Java's 'final' class final ( type ): def __init__ ( cls , name , bases , namespace ): super ( final , cls ) . __init__ ( name , bases , namespace ) for klass in bases : if isinstance ( klass , final ): raise TypeError ( str ( klass . __name__ ) + \" is final\" ) class A ( object ): pass class B ( A , metaclass = final ): pass print ( B . __bases__ ) print ( isinstance ( B , final )) # Produces compile-time error: class C ( B ): pass \"\"\" Output: (<class '__main__.A'>,) True ... TypeError: B is final \"\"\" 上面的例子在创建\"类\"对象时，检查是否有任何的基类派生于 final 注意，使用元类会使新的类型成为这个元类的实例，即使元类没有出现在基类列表中。 因为这个检查最终结果的过程需要在创建子类时安装，而不是在类装饰器之后执行，所以这似乎是一个需要元类而不能用类装饰器完成的事情的例子。 使用元类的 __init__ 还是 __new__ 方法 在看到一些元类任意使用 __init__ 和 __new__ 的例子时你可能感到困惑，为什么只选择其中一个而不是用另一个。 __new__ 在新的\"类\"对象创建时被调用，然而 __init__ 是在类对象被创建后调用，在返回给调用者之前执行额外的初始化操作。 from pprint import pprint class Tag1 : pass class Tag2 : pass class Tag3 : def tag3_method ( self ): pass class MetaBase ( type ): def __new__ ( mcl , name , bases , nmspc ): print ( 'MetaBase.__new__ \\n ' ) return super ( MetaBase , mcl ) . __new__ ( mcl , name , bases , nmspc ) def __init__ ( cls , name , bases , nmspc ): print ( 'MetaBase.__init__ \\n ' ) super ( MetaBase , cls ) . __init__ ( name , bases , nmspc ) class MetaNewVSInit ( MetaBase ): def __new__ ( mcl , name , bases , nmspc ): # First argument is the metaclass ``MetaNewVSInit`` print ( 'MetaNewVSInit.__new__' ) for x in ( mcl , name , bases , nmspc ): pprint ( x ) print ( '' ) # These all work because the class hasn't been created yet: if 'foo' in nmspc : nmspc . pop ( 'foo' ) name += '_x' bases += ( Tag1 ,) nmspc [ 'baz' ] = 42 return super ( MetaNewVSInit , mcl ) . __new__ ( mcl , name , bases , nmspc ) def __init__ ( cls , name , bases , nmspc ): # First argument is the class being initialized print ( 'MetaNewVSInit.__init__' ) for x in ( cls , name , bases , nmspc ): pprint ( x ) print ( '' ) if 'bar' in nmspc : nmspc . pop ( 'bar' ) # No effect name += '_y' # No effect bases += ( Tag2 ,) # No effect nmspc [ 'pi' ] = 3.14159 # No effect super ( MetaNewVSInit , cls ) . __init__ ( name , bases , nmspc ) # These do work because they operate on the class object: cls . __name__ += '_z' cls . __bases__ += ( Tag3 ,) cls . e = 2.718 class Test ( metaclass = MetaNewVSInit ): def __init__ ( self ): print ( 'Test.__init__' ) def foo ( self ): print ( 'foo still here' ) def bar ( self ): print ( 'bar still here' ) t = Test () print ( 'class name: ' + Test . __name__ ) print ( 'base classes: ' , [ c . __name__ for c in Test . __bases__ ]) print ([ m for m in dir ( t ) if not m . startswith ( \"__\" )]) t . bar () print ( t . e ) \"\"\" Output: MetaNewVSInit.__new__ <class '__main__.MetaNewVSInit'> 'Test' (<type 'object'>,) {'__init__': <function __init__ at 0x7ecf0>, '__metaclass__': <class '__main__.MetaNewVSInit'>, '__module__': '__main__', 'bar': <function bar at 0x7ed70>, 'foo': <function foo at 0x7ed30>} MetaBase.__new__ MetaNewVSInit.__init__ <class '__main__.Test_x'> 'Test' (<type 'object'>,) {'__init__': <function __init__ at 0x7ecf0>, '__metaclass__': <class '__main__.MetaNewVSInit'>, '__module__': '__main__', 'bar': <function bar at 0x7ed70>, 'baz': 42} MetaBase.__init__ Test.__init__ class name: Test_x_z ('base classes: ', ['object', 'Tag1', 'Tag3']) ['bar', 'baz', 'e', 'tag3_method'] bar still here 2.718 \"\"\" 不过最主要的区别在于当重写（ overriding ） __new__() 方法时你可以在调用父类构造函数之前修改类型的 name , bases , 以及 namespace 等参数，这时修改是生效的。但是在 __init__ 方法中做同样的事情，修改则不会生效。 一个特殊的例子是你可以在 __new__ 中操作 __slot__ 但是在 __init__ 中则不行。 请注意，由于 __init__() 的基类版本没有做任何修改，所以首先调用它，然后执行任何附加操作是有意义的。在c++和Java中，基类构造函数必须作为 派生类构造函数中的第一个操作调用，这是有意义的，因为派生类构造可以在基类的基础上构建。 在大多数情况下选择 __new__ 或者 __init__ 是一个风格问题，并不重要。但因为 __new__() 可以做所有的事情，而 __init__() 稍微有一些限制，一些人只是开始使用 __new__() 并坚持使用它。这种用法可能会让人困惑——我倾向于寻找 __init__() 被选择的原因，如果 我找不到它，就会怀疑作者是否知道他们在做什么。我更喜欢只在 __new__() 有意义的时候使用它——当你必须改变只有 __new__() 可以改变的 东西时。 类方法和元类方法 元类方法可以在元类或者\"类\"对象中调用，但是不能从\"类\"对象的实例中调用。 类方法可以在类上调用或者是类的实例上去调用，但并不是元类的一部分。 拦截类的创建 下面的例子使用元类实现了单例模式（ Singleton ）通过重写元类 __call__ 方法， 这将在\"类\"对象实例化实例时被调用。 class Singleton ( type ): instance = None def __call__ ( cls , * args , ** kw ): if not cls . instance : cls . instance = super ( Singleton , cls ) . __call__ ( * args , ** kw ) return cls . instance class ASingleton ( metaclass = Singleton ): pass a = ASingleton () b = ASingleton () assert a is b print ( a . __class__ . __name__ , b . __class__ . __name__ ) class BSingleton ( metaclass = Singleton ): c = BSingleton () d = BSingleton () assert c is d print ( c . __class__ . __name__ , d . __class__ . __name__ ) assert c is not a \"\"\" Output: ('ASingleton', 'ASingleton') ('BSingleton', 'BSingleton') \"\"\" 通过在元类上重写 __call__ 方法，将拦截\"类\"对象的实例创建过程，如果类的 instance 已被创建，则再次实例化时会跳过实例化过程。 注意上面对元类静态字段 instance 行为的依赖, 当 cls.instance 第一次被读取时，它的值取自元类的静态字段 instance 为 None 当之后进行赋值时，python会为特定的类创建一个本地的版本，下次读取则是从 cls.instance 类的本地版本中读取值。由于这种行为，每个类最终都 有自己的特定于类的实例字段(因此实例并没有从元类中\"继承\")。 类装饰器实现的单例 def singleton ( klass ): \"Simple replacement of object creation operation\" def getinstance ( * args , ** kw ): if not hasattr ( klass , 'instance' ): klass . instance = klass ( * args , ** kw ) return klass . instance return getinstance def singleton ( klass ): \"\"\" More powerful approach: Change the behavior of the instances AND the class object. \"\"\" class Decorated ( klass ): def __init__ ( self , * args , ** kwargs ): if hasattr ( klass , '__init__' ): klass . __init__ ( self , * args , ** kwargs ) def __repr__ ( self ) : return klass . __name__ + \" obj\" __str__ = __repr__ Decorated . __name__ = klass . __name__ class ClassObject : def __init__ ( cls ): cls . instance = None def __repr__ ( cls ): return klass . __name__ __str__ = __repr__ def __call__ ( cls , * args , ** kwargs ): print str ( cls ) + \" __call__ \" if not cls . instance : cls . instance = Decorated ( * args , ** kwargs ) return cls . instance return ClassObject () @singleton class ASingleton : pass a = ASingleton () b = ASingleton () print ( a , b ) print a . __class__ . __name__ print ASingleton assert a is b @singleton class BSingleton : def __init__ ( self , x ): self . x = x c = BSingleton ( 11 ) d = BSingleton ( 22 ) assert c is d assert c is not a \"\"\" Output: ASingleton __call__ ASingleton __call__ (ASingleton obj, ASingleton obj) ASingleton ASingleton BSingleton __call__ BSingleton __call__ \"\"\" __prepare__() 元类方法 使用类装饰器不能做的一件事是替换默认字典。在Python 3中，这是通过 __prepare__() 元方法启用的: @classmethod def __prepare__ ( mcl , name , bases ): return odict () 对于在元类中同时使用 __prepare__() 和 __slot__() 的例子，请前往 Michele Simionato's article metaclass 冲突 注意， metaclass 参数是单数的——你不能给一个类附加一个以上的元类。然而通过多重继承，可能会意外地得到多个元类，这将产生必须解决的冲突。 http://code.activestate.com/recipes/204197/ 进一步阅读 Excellent step-by-step introduction to metaclasses : http://cleverdevil.org/computing/78/ Metaclass intro and comparison of syntax between Python 2.x and 3.x : http://mikewatkins.ca/2008/11/29/python-2-and-3-metaclasses/ David Mertz's metaclass primer : http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html Three-part in-depth coverage of metaclasses on IBM Developer Works. Quite useful and authoritative : http://www.ibm.com/developerworks/linux/library/l-pymeta.html http://www.ibm.com/developerworks/linux/library/l-pymeta2/ http://www.ibm.com/developerworks/linux/library/l-pymeta3.html Michele Simionato's articles on Artima, with special emphasis on the difference between Python 2.x and 3.x metaclasses : http://www.artima.com/weblogs/viewpost.jsp?thread=236234 http://www.artima.com/weblogs/viewpost.jsp?thread=236260 一旦你理解了这些基础，你可以通过关键字 metaclass 在 Python Cookbook: http://code.activestate.com/recipes/langs/python/ 上搜索到大量的例子。 Python Cookbook 的印刷版比在线版的示例要少得多，但是印刷版经过了过滤和编辑，因此往往更权威。 Ian Bicking writes about metaclasses : http://blog.ianbicking.org/a-conservative-metaclass.html http://blog.ianbicking.org/metaclass-fun.html http://blog.ianbicking.org/A-Declarative-Syntax-Extension.html http://blog.ianbicking.org/self-take-two.html 大量关于类、类型、元类等的有用信息，包括Python 2.2文档中的历史信息(在后续版本的文档中是否重复): http://www.python.org/download/releases/2.2/descrintro/ 对于更高级的学习，请参阅 Putting Metaclasses to Work 一书。","tags":"Python","url":"/MetaClassProgramming","loc":"/MetaClassProgramming"},{"title":"常见 git 别名配置","text":"注意 此非原创，源博文地址 https://github.com/dwqs/blog/issues/3 简化常用的 git 命令的别名 这些常用的 git 别名非常好用, 打开命令行输入 git config --global --edit 然后加入下面配置 [alias] # Shortening aliases co = checkout cob = checkout -b f = fetch -p c = commit p = push ba = branch -a bd = branch -d bD = branch -D dc = diff --cached # Feature improving aliases st = status -sb a = add -p # Complex aliases plog = log --graph --pretty='format:%C(red)%d%C(reset) %C(yellow)%h%C(reset) %ar %C(green)%aN%C(reset) %s' tlog = log --stat --since='1 Day Ago' --graph --pretty=oneline --abbrev-commit --date=relative lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit rank = shortlog -sn --no-merges bdm = \"!git branch --merged | grep -v '*' | xargs -n 1 git branch -d\"","tags":"Others","url":"/git_config","loc":"/git_config"},{"title":"赞乎产品需求规格说明书","text":"注意 版权说明 本文档属于XX软件有限公司所有的机密材料。 在获得XX软件有限公司直接的书面允许之前， 本文档中的任何部分均不得用各种方法或形式复制或公布于众。 这些方法包括电子或机械的方法， 如影印或各种信息存储或重复取用系统。 同样，在获得XX软件有限公司直接的书面允许之前， 本文章中的任何部分也不得向第三方披露 赞乎产品需求规格说明书 文档编号 V 0.1.0 编写人 Nico 模块名称 赞乎需求说明 部门 研发部 保密等级 极密 日期 2020年03月15日 第一章 修订页 编号 章节名称 修订内容简述 修订日期 修订前版本号 修订后版本号 修订人 批准人 001 第二章 项目概述 2.1 产品描述 赞乎是一个类似于知乎的知识问答社区，连接各行各业的用户。用户分享着彼此的知识、经验和见解，为中文互联网源源不断地提供多种多样的信息。 2.2 产品功能 本产品为PC端，具有当今主流知识问答应用的功能，包括个人中心、动态、文章、问答、私信、消息通知、网站搜索，对外开放邮箱注册。 第三章 业务需求 3.1 总体需求 本产品不包含后台管理系统 网站所有内容需要用户登陆后才能访问 3.2 用户个人中心 3.2.1 登录/注册/退出 可以邮箱注册，使用第三方应用微信或Github注册登录，用户名登录，支持邮箱找回和重置密码。 3.2.2 个人信息 包括昵称、邮箱、头像、简介、职称、城市、个人链接、微博链接、知乎链接、Github链接、LinkedIn链接，用户可以更新。 3.3.3 用户信息统计 显示用户自网站注册日起，发表动态的数量，已发表文章的数量，参与评论的数量，提问的数量，回答问题的数量，用户的互动总数。 3.3 首页动态功能 3.3.1 动态列表页 最上方有\"发表动态\"按钮，每页显示20条动态 动态下有点赞和评论按钮 每条动态除内容外要显示用户头像、昵称、发表时间、赞和评论数量，用户互动后能自动更新数量 对于登录用户发表的动态，右上角显示删除按钮 3.3.2 发表动态 发表动态字数不限，畅所欲言。 3.3.3 删除动态 用户可以删除自己发表的动态。 3.3.4 用户点赞 可以给自己和其他人点赞，也可以取消赞。 3.3.5 用户评论 评论不能删除，除非状态被发表人删除 3.4 文章模块 如下4个功能点中，第1、2、3各使用一页，页面上方有面包屑可以跳转； 3.4.1 浏览文章页 每页显示10篇文章 每篇文章显示标题、图片、内容的前100个字、发表人、发表时间、文章标签已经阅读全文的按钮 文章页要显示\"写文章\"和\"草稿箱\"按钮，云标签 3.4.2 文章详情页面 每篇文章显示标题、图片、内容、发表人、发表时间 文章页要显示\"写文章\"和\"编辑\"按钮，云标签 文章下方有评论区 3.4.3 写文章 用户必填字段为标题、内容、文章图片、标签，标签支持多个使用英文逗号隔开 编辑文章内容时可Markdown实时预览 用户可将文章发表或保存为草稿，或者取消 3.4.4 保存草稿 草稿箱与浏览文章页功能一样，不用之处在于用户只能看到自己保存的草稿。 3.4.5 评论文章 用户评论时必填昵称、邮箱地址、内容，选填URL 3.5 问答模块 3.5.1 问答页 页面上方有面包屑，下面是话题分类和提问按钮，下面是3个Tab栏目：待回答问题页、已回答问题页、所有问题页，每页显示20个问题； ​每个问题需要显示：回答的数量、问题的投票数量、标题、内容的前100个字符、提问者、提问时间、问题标签 3.5.2 问题详情页 页面上方有面包屑，显示问题的所有回答 问题需要显示：回答的数量、问题的投票数量、标题、内容的前100个字符、提问者、提问时间、问题标签；用户可以给问题投票，有提问按钮和回答按钮 回答需要显示：回答的投票数、回答用户的头像和昵称、答案内容、回答时间、如果回答被接受显示对勾；用户可以给回答投票 3.5.3 用户提问 用户必填字段为标题、内容、标签，标签支持多个使用英文逗号隔开 编辑文章内容时可Markdown实时预览 用户可将问题发表或保存为草稿，或者取消 问题不能修改或删除 3.5.4 回答问题 页面上方有面包屑，填写回答内容时可Markdown实时预览；回答不能修改或删除 3.5.5 给问题或回答投票 显示票数=赞同数 - 反对数，用户可以赞同或反对，随时取消赞同或反对 3.5.6 提问者接受回答 只能接受一个回答，接受后不能取消 3.6 私信功能 每页显示可私信的20个用户 对话框默认选中最近一次私信互动的用户 可与其他用户在线聊天 聊天内容显示头像、昵称、时间、内容，点击昵称可跳转至用户个人中心 3.7 消息通知 当其它用户与我有如下互动时能接收到通知： 赞了我的状态 评论了我的动态或文章 收藏了我的文章 回答了我的提问 接受了我的回答 回复了我的评论 3.7.1 通知下拉框 显示最近收到的5条消息通知，包括昵称、互动类型、互动对象、互动时间；有\"查看所有通知\"和\"全部标为已读\"按钮 3.7.2 未读通知列表 显示所有的消息通知，有全部标为已读按钮； 每条消息通知包括用户头像、昵称、互动类型、互动对象、互动时间，有\"标为已读\"按钮； 3.8 全站搜索 可以搜索文章、动态、问题、用户、标签； 文章搜索结果：显示文章图片、标题（可跳转）、内容的前100个字 动态搜索结果：与首页的显示的动态信息一致 问题搜索结果：与问答页显示的问题信息一致 用户搜索结果：显示用户头像（可跳转）、昵称（可发邮件）、职位、城市 标签搜索结果：显示被搜索到的标签 第四章 附录","tags":"Django开发企业级应用","url":"/django_in_practice","loc":"/django_in_practice"},{"title":"NodeJs开发环境搭建实践","text":"注解 本开发搭建实践指南中所有示例代码采自 《Learning JavaScript》第三版 英文原书中， 由于书中工具集可能比较旧，所以在安装对应工具集时，确认好版本。 开始前新建一个项目目录，并运行下面指令初始化项目目录 npm init 开发工具集合 Node 允许脱离浏览器运行 javascript 脚本 Gulp 自动化构建工具 Babel javascript 语法转译器， 支持 ES6 -> ES5 语法转换 ESLint javascript 代码检查，让你避免常见错误，保证代码健壮性 NodeJs版本 nicodeMacBook-Pro:GitHub nico$ node -v v12.13.0 nicodeMacBook-Pro:GitHub nico$ npm -v 6.12.0 安装 Gulp 自动化构建工具 全局安装 gulp (只安装一次？) nicodeMacBook-Pro:GitHub nico$ npm install -g gulp /usr/local/bin/gulp -> /usr/local/lib/node_modules/gulp/bin/gulp.js > fsevents@1.2.9 install /usr/local/lib/node_modules/gulp/node_modules/fsevents > node install node-pre-gyp WARN Using needle for node-pre-gyp https download [fsevents] Success: \"/usr/local/lib/node_modules/gulp/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64/fse.node\" is installed via remote + gulp@4.0.2 added 384 packages from 238 contributors in 14.761s nicodeMacBook-Pro:GitHub nico$ gulp -v CLI version: 2.2.0 Local version: Unknown 安装完成后，在项目根目录安装项目本地的 gulp nicodeMacBook-Pro:NodePractice nico$ npm --save-dev install gulp 测试 gulp 是否正常工作,在项目根目录下新建 gulpfile.js nicodeMacBook-Pro:NodePractice nico$ ls gulpfile.js node_modules package-lock.json gulpfile.js const gulp = require ( 'gulp' ); // Gulp dependencies go here gulp . task ( 'default' , function () { // Gulp tasks go here }); 直接执行 gulp nicodeMacBook-Pro:NodePractice nico$ gulp [21:33:29] Using gulpfile ~/GitHub/NodePractice/gulpfile.js [21:33:29] Starting 'default'... [21:33:29] The following tasks did not complete: default [21:33:29] Did you forget to signal async completion? 似乎报错了，应该是示例代码太老了，可以参考 这篇文章的解决办法 安装 Babel npm install --save-dev gulp-babel @babel/core @babel/preset-env 创建 .babelrc, 加入下面 babel 配置。 { \"presets\" : [ \"@babel/preset-env\" ] } 测试 babel 是否正常工作，打开 gulpfile.js 加入下面代码。 const gulp = require ( 'gulp' ); const babel = require ( 'gulp-babel' ); // Gulp dependencies go here gulp . task ( 'default' , function () { // Gulp tasks go here gulp . src ( \"es6/**/*.js\" ) . pipe ( babel ()) . pipe ( gulp . dest ( \"dist\" )); // browser source gulp . src ( \"public/es6/**/*.js\" ) . pipe ( babel ()) . pipe ( gulp . dest ( \"public/dist\" )); }); 在 es6 目录下新建一个 test.js 文件。 'use strict' ; // es6 feature: block-scoped \"let\" declaration const sentences = [ { subject : 'JavaScript' , verb : 'is' , object : 'great' }, { subject : 'Elephants' , verb : 'are' , object : 'large' }, ]; // es6 feature: object destructuring function say ({ subject , verb , object }) { // es6 feature: template strings console . log ( ` ${ subject } ${ verb } ${ object } ` ); } // es6 feature: for..of for ( let s of sentences ) { say ( s ); } 最后在项目根目录执行 gulp, 后会发现在 dist 目录下生成对应 es5 脚本文件。 'use strict' ; // es6 feature: block-scoped \"let\" declaration var sentences = [{ subject : 'JavaScript' , verb : 'is' , object : 'great' }, { subject : 'Elephants' , verb : 'are' , object : 'large' }]; // es6 feature: object destructuring function say ( _ref ) { var subject = _ref . subject , verb = _ref . verb , object = _ref . object ; // es6 feature: template strings console . log ( \"\" . concat ( subject , \" \" ). concat ( verb , \" \" ). concat ( object )); } // es6 feature: for..of for ( var _i = 0 , _sentences = sentences ; _i < _sentences . length ; _i ++ ) { var s = _sentences [ _i ]; say ( s ); } 使用 node 执行在 dist 目录转译后的 test.js 文件 nicodeMacBook-Pro:NodePractice nico$ node dist/test.js JavaScript is great Elephants are large 安装 ESLint npm install -g eslint /usr/local/bin/eslint -> /usr/local/lib/node_modules/eslint/bin/eslint.js + eslint@6.6.0 added 121 packages from 75 contributors in 5.228s 在项目根目录下通过下面指令生成 .eslintrc 文件。 eslint --init 警告 在运行上面指令时，确保项目根目录下存在 package.json 文件，如果不存在，请首先通过以下指令进行生成。 npm init 安装 gulp-eslint nicodeMacBook-Pro:NodePractice nico$ npm install --save-dev gulp-eslint npm WARN eslint-plugin-vue@5.2.3 requires a peer of eslint@&#94;5.0.0 but none is installed. You must install peer dependencies yourself. npm WARN gulp-babel@8.0.0 requires a peer of @babel/core@&#94;7.0.0 but none is installed. You must install peer dependencies yourself. npm WARN tsutils@3.17.1 requires a peer of typescript@>=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta but none is installed. You must install peer dependencies yourself. npm WARN vue-eslint-parser@5.0.0 requires a peer of eslint@&#94;5.0.0 but none is installed. You must install peer dependencies yourself. npm WARN nodepractice@1.0.0 No description npm WARN nodepractice@1.0.0 No repository field. + gulp-eslint@6.0.0 added 1 package from 2 contributors in 2.053s 修改项目根目录下的 gulp.js const gulp = require ( 'gulp' ); const babel = require ( 'gulp-babel' ); const eslint = require ( 'gulp-eslint' ); gulp . task ( 'default' , function () { // Run ESLint gulp . src ([ \"es6/**/*.js\" , \"public/es6/**/*.js\" ]) . pipe ( eslint ()) . pipe ( eslint . format ()); // Node source gulp . src ( \"es6/**/*.js\" ) . pipe ( babel ()) . pipe ( gulp . dest ( \"dist\" )); // browser source gulp . src ( \"public/es6/**/*.js\" ) . pipe ( babel ()) . pipe ( gulp . dest ( \"public/dist\" )); }); 项目根目录下执行 gulp nicodeMacBook-Pro:NodePractice nico$ gulp [23:52:40] Using gulpfile ~/GitHub/NodePractice/gulpfile.js [23:52:40] Starting 'default'... [23:52:40] /Users/nico/GitHub/NodePractice/es6/test.js 1:13 error Extra semicolon semi 4:1 error Expected indentation of 2 spaces but found 8 indent 5:1 error Expected indentation of 2 spaces but found 8 indent 5:63 error Unexpected trailing comma comma-dangle 6:2 error Extra semicolon semi 8:13 error Missing space before function parentheses space-before-function-paren 9:1 error Expected indentation of 2 spaces but found 5 indent 9:38 error Trailing spaces not allowed no-trailing-spaces 10:1 error Expected indentation of 2 spaces but found 5 indent 10:49 error Extra semicolon semi 13:1 error Expected space(s) after \"for\" keyword-spacing 13:9 error 's' is never reassigned. Use 'const' instead prefer-const 14:1 error Expected indentation of 2 spaces but found 5 indent 14:12 error Extra semicolon semi ✖ 14 problems (14 errors, 0 warnings) 14 errors and 0 warnings potentially fixable with the `--fix` option. NodeJs工程结构 如下 dist 目录用于存放 node 服务端 es6 转译后的 es5 代码，es6 目录存放 node 服务端代码， public/es6，及 public/dist 分别存放浏览器端的 es6 代码，和 es5 代码。 . ├── dist ├── es6 ├── gulpfile.js ├── node_modules ├── package-lock.json ├── package.json └── public ├── dist └── es6 最后到这，就可以进行基本 Node 开发了。","tags":"Nodejs","url":"/nodejs_practice","loc":"/nodejs_practice"},{"title":"ScrapyRedis集成Bloomfilter","text":"新建 dupfilters package #!usr/bin/env python #-*- coding:utf-8 -*- \"\"\" @author: nico @file: __init__.py @time: 2018/08/31 \"\"\" import os import logging from scrapy.dupefilters import BaseDupeFilter , RFPDupeFilter from scrapy.utils.request import request_fingerprint from scrapy.utils.job import job_dir from scrapy_redis.connection import get_redis_from_settings from robot.dupefilters import bloomfilter_memory , bloomfilter_redis logger = logging . getLogger ( 'dupefilters' ) class BloomFilterRedis ( BaseDupeFilter ): def __init__ ( self , n = 100000000 , f = 0.0001 , server = None , block_nums = 1 , key_prefix = 'BLOOMFILTER' , * args , ** kwargs ): self . bf = bloomfilter_redis . BloomFilter ( n , f , server , block_nums , key_prefix ) self . debug = kwargs . get ( 'debug' , True ) self . logdupes = True @classmethod def from_settings ( cls , settings ): server = get_redis_from_settings ( settings ) key_prefix = settings . get ( \"BLOOMFILTER_REDIS_KEY_PREFIX\" , \"BLOOMFILTER\" ) capacity = settings . get ( \"BLOOMFILTER_REDIS_CAPACITY\" , 100000000 ) error_rate = settings . get ( \"BLOOMFILTER_REDIS_FALSE_POSITIVE_PROBABILITY\" , 0.0001 ) block_nums = settings . get ( \"BLOOMFILTER_REDIS_BLOCK_NUMS\" , 1 ) debug = settings . getbool ( 'DUPEFILTER_DEBUG' , False ) return cls ( capacity , error_rate , server , block_nums , key_prefix , debug = debug ) @classmethod def from_spider ( cls , spider ): settings = spider . settings server = get_redis_from_settings ( settings ) key_prefix = settings . get ( \"BLOOMFILTER_REDIS_KEY_PREFIX\" , \"BLOOMFILTER\" ) capacity = settings . get ( \"BLOOMFILTER_REDIS_CAPACITY\" , 100000000 ) error_rate = settings . get ( \"BLOOMFILTER_REDIS_FALSE_POSITIVE_PROBABILITY\" , 0.0001 ) block_nums = settings . get ( \"BLOOMFILTER_REDIS_BLOCK_NUMS\" , 1 ) debug = settings . getbool ( 'DUPEFILTER_DEBUG' , False ) return cls ( capacity , error_rate , server , block_nums , key_prefix , debug = debug ) @classmethod def from_crawler ( cls , crawler ): return cls . from_settings ( crawler . settings ) def request_seen ( self , request ): fp = request_fingerprint ( request ) if fp in self . bf : return True else : self . bf . add ( fp ) return False def open ( self ): pass def close ( self , reason ): if self . bf . key : self . bf . server . delete ( self . bf . key ) def log ( self , request , spider ): if self . debug : msg = \"Filtered duplicate request: %(request)s \" logger . debug ( msg , { 'request' : request }, extra = { 'spider' : spider }) elif self . logdupes : msg = ( \"Filtered duplicate request %(request)s \" \" - no more duplicates will be shown\" \" (see DUPEFILTER_DEBUG to show all duplicates)\" ) logger . debug ( msg , { 'request' : request }, extra = { 'spider' : spider }) self . logdupes = False @classmethod def from_crawler ( cls , crawler ): return cls . from_settings ( crawler . settings ) def request_seen ( self , request ): fp = request_fingerprint ( request ) if fp in self . bf : return True else : self . bf . add ( fp ) if self . file : self . file . write ( fp + os . linesep ) return False def log ( self , request , spider ): if self . debug : msg = \"Filtered duplicate request: %(request)s \" logger . debug ( msg , { 'request' : request }, extra = { 'spider' : spider }) elif self . logdupes : msg = ( \"Filtered duplicate request %(request)s \" \" - no more duplicates will be shown\" \" (see DUPEFILTER_DEBUG to show all duplicates)\" ) logger . debug ( msg , { 'request' : request }, extra = { 'spider' : spider }) self . logdupes = False 重构ScrapyRedis调度器 #!usr/bin/env python # -*- coding:utf-8 -*- \"\"\" @author: nico @file: schedulers.py @time: 2018/09/02 \"\"\" from scrapy.utils.misc import load_object from scrapy_redis import scheduler as redis_scheduler from scrapy.core import scheduler class RedisScheduler ( redis_scheduler . Scheduler ): def open ( self , spider ): self . spider = spider try : self . queue = load_object ( self . queue_cls )( server = self . server , spider = spider , key = self . queue_key % { 'spider' : spider . name }, serializer = self . serializer , ) except TypeError as e : raise ValueError ( \"Failed to instantiate queue class ' %s ': %s \" , self . queue_cls , e ) try : self . df = load_object ( self . dupefilter_cls )( capacity = spider . settings . get ( \"BLOOMFILTER_REDIS_CAPACITY\" , 100000000 ), error_rate = spider . settings . get ( \"BLOOMFILTER_REDIS_FALSE_POSITIVE_PROBABILITY\" , 0.0001 ), server = self . server , key_prefix = self . dupefilter_key % { 'spider' : spider . name }, block_nums = spider . settings . get ( \"BLOOMFILTER_REDIS_BLOCK_NUMS\" , 1 ), debug = spider . settings . getbool ( 'DUPEFILTER_DEBUG' ), ) except TypeError as e : raise ValueError ( \"Failed to instantiate dupefilter class ' %s ': %s \" , self . dupefilter_cls , e ) if self . flush_on_start : self . flush () # notice if there are requests already in the queue to resume the crawl if len ( self . queue ): spider . log ( \"Resuming crawl ( %d requests scheduled)\" % len ( self . queue )) 在 settings.py 中添加类似如下的配置 SCHEDULER = \"robot.schedulers.RedisScheduler\" DUPEFILTER_CLASS = \"robot.dupefilters.BloomFilterRedis\"","tags":"Scrapy","url":"/scrapyredis-bloomfilter","loc":"/scrapyredis-bloomfilter"},{"title":"高效去重算法Bloomfilter","text":"基于redis实现Bloomfilter #!usr/bin/env python # -*- coding:utf-8 -*- \"\"\" @author: nico @file: bloomfilter_redis.py @time: 2018/08/31 \"\"\" import math import mmh3 class BloomFilter : def __init__ ( self , n , f , server , block_num = 1 , key_prefix = 'BLOOMFILTER' ): \"\"\" m: number of bit as least to be assign k: number of hash as least need :param n: number of items is going to add :param f: expected false positive probability :param server: the redis client instance :param block_num: number of redis block, one of block maxsize 512m , 2**32 :param key_prefix: the block key prefix \"\"\" if not ( 0 < f < 1 ): raise ValueError ( \"f must be between 0 and 1.\" ) if not n > 0 : raise ValueError ( \"n must be > 0\" ) self . n = n self . f = f self . k = math . ceil ( math . log ( 1.0 / f , 2 )) self . m = 1 << 31 # 2**32 self . server = server self . key_prefix = key_prefix self . block_num = block_num def __contains__ ( self , item ): item = str ( item ) key = self . __get_block_route_key ( item ) res = True for seed in range ( self . k ): offset = mmh3 . hash ( item , seed , signed = False ) res = res & self . server . getbit ( key , offset % self . m ) return True if res else False def add ( self , item ): item = str ( item ) self . key = self . __get_block_route_key ( item ) for seed in range ( self . k ): offset = mmh3 . hash ( item , seed , signed = False ) self . server . setbit ( self . key , offset % self . m , 1 ) def __get_block_route_key ( self , hashable ): return self . key_prefix + str ( sum ( map ( ord , hashable )) % self . block_num ) if __name__ == '__main__' : from redis import StrictRedis client = StrictRedis () bf = BloomFilter ( 100000000 , 0.0001 , client ) test_str = [ \"python\" , \"c\" , \"c++\" , \"ruby\" ] for el in test_str : bf . add ( el ) print ( list ( map ( lambda _ : _ in bf , [ 'lua' , 'python' , 'go' , 'c' ]))) # [False, True, False, True] 基于内存实现Bloomfilter #!usr/bin/env python # -*- coding:utf-8 -*- \"\"\" @author: nico @file: bloomfilter_memory.py @time: 2018/08/31 \"\"\" import math import mmh3 import bitarray class BloomFilter : def __init__ ( self , n , f , block_num = 1 ): \"\"\" m: number of bit as least to be assign k: number of hash as least need :param n: number of items is going to add :param f: expected false positive probability :param block_num: number of bitarray obj, one block maxsize 16Gb on 32 bit systems \"\"\" if not ( 0 < f < 1 ): raise ValueError ( \"f must be between 0 and 1.\" ) if not n > 0 : raise ValueError ( \"n must be > 0\" ) self . n = n self . f = f self . k = math . ceil ( math . log ( 1.0 / f , 2 )) self . m = math . ceil ( - self . k / math . log ( 1 - math . exp ( math . log ( f ) / self . k )) * n ) self . block_num = block_num self . store = { i : bitarray . bitarray ( self . m , endian = 'little' ) for i in range ( self . block_num )} for el in self . store . values (): el . setall ( False ) def __contains__ ( self , item ): item = str ( item ) flag = True for seed in range ( self . k ): offset = mmh3 . hash ( item , seed , signed = False ) flag = flag & self . store [ offset % self . block_num ][ offset % self . m ] return True if flag else False def add ( self , item ): item = str ( item ) for seed in range ( self . k ): offset = mmh3 . hash ( item , seed , signed = False ) self . store [ offset % self . block_num ][ offset % self . m ] = 1 if __name__ == \"__main__\" : bf = BloomFilter ( 100000000 , 0.0001 , block_num = 2 ) test_str = [ \"python\" , \"c\" , \"c++\" , \"ruby\" , 1 , 2 , 3 ] for el in test_str : bf . add ( el ) print ( list ( map ( lambda _ : _ in bf , [ 'lua' , 'python' , 'go' , 'c' , 4 , 2 , 1 ]))) # [False, True, False, True, False, True, True]","tags":"Algorithms","url":"/bloomfilter","loc":"/bloomfilter"}]};